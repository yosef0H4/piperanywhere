--- File: .\AudioSettings.ahk

; Updated AudioSettings.ahk - Now supports dynamic paths from DependencyChecker
#Requires AutoHotkey v2

class AudioSettings {
    
    __New() {
        this.useAudioEnhancement := true
        this.speechSpeed := 1.0
        this.volumeBoost := 2
        this.sentenceSilence := 0.2
        this.minWordsPerSentence := 6
        this.maxWordsPerSentence := 25
        
        ; Default paths (will be updated by DependencyChecker)
        this.piperPath := ".\piper\piper.exe"
        this.ffmpegPath := ".\ffmpeg\bin\ffmpeg.exe"
        this.ffplayPath := ".\ffmpeg\bin\ffplay.exe"
    }
    
    ; Set the paths for executables (called by DependencyChecker)
    SetExecutablePaths(piperPath, ffmpegPath, ffplayPath) {
        this.piperPath := piperPath
        this.ffmpegPath := ffmpegPath
        this.ffplayPath := ffplayPath
    }
    
    SetEnhancement(enabled) {
        this.useAudioEnhancement := enabled
    }
    
    SetSpeed(speed) {
        if (IsNumber(speed) && speed > 0) {
            this.speechSpeed := speed
            return true
        }
        return false
    }
    
    SetVolume(volume) {
        if (IsNumber(volume)) {
            this.volumeBoost := volume
            return true
        }
        return false
    }
    
    SetMinWords(minWords) {
        if (IsNumber(minWords) && minWords > 0) {
            this.minWordsPerSentence := minWords
            return true
        }
        return false
    }
    
    SetMaxWords(maxWords) {
        if (IsNumber(maxWords) && maxWords > 0) {
            this.maxWordsPerSentence := maxWords
            return true
        }
        return false
    }
    
    GetQualityDescription() {
        if (this.useAudioEnhancement) {
            return "üéµ Enhanced: Dynamic Normalization + Volume Control + Speech Compression"
        } else {
            return "üîá Standard: Direct Piper output"
        }
    }
    
    BuildAudioCommand(voiceFile, tempTextFile) {
        ; Build the piper command with dynamic path
        piperCmd := 'type "' . tempTextFile . '" | "' . this.piperPath . '" --model ".\voices\' . voiceFile . '"'
        piperCmd .= ' --length_scale ' . (1 / this.speechSpeed)
        piperCmd .= ' --sentence_silence ' . this.sentenceSilence
        piperCmd .= ' --output-raw'
        
        if (this.useAudioEnhancement) {
            audioFilters := "dynaudnorm=p=0.9:s=5"
            
            if (this.volumeBoost != 0) {
                audioFilters .= ",volume=" . this.volumeBoost . "dB"
            }
            
            audioFilters .= ",compand=.3|.3:1|1:-90/-60|-60/-40|-40/-30|-20/-20:6:0:-90:0.2"
            
            command := A_ComSpec . ' /c ' . piperCmd 
            command .= ' | "' . this.ffmpegPath . '" -f s16le -ar 22050 -ch_layout mono -i - -af "' . audioFilters . '" -f wav -'
            command .= ' | "' . this.ffplayPath . '" -f wav -nodisp -autoexit -'
        } else {
            command := A_ComSpec . ' /c ' . piperCmd
            command .= ' | "' . this.ffplayPath . '" -f s16le -ar 22050 -ch_layout mono -nodisp -autoexit -'
        }
        
        return command
    }
    
    BuildSaveCommand(voiceFile, tempTextFile, outputFile) {
        ; Build the piper command with dynamic path
        piperCmd := 'type "' . tempTextFile . '" | "' . this.piperPath . '" --model ".\voices\' . voiceFile . '"'
        piperCmd .= ' --length_scale ' . (1 / this.speechSpeed)
        piperCmd .= ' --sentence_silence ' . this.sentenceSilence
        piperCmd .= ' --output-raw'
        
        if (this.useAudioEnhancement) {
            audioFilters := "dynaudnorm=p=0.9:s=5"
            
            if (this.volumeBoost != 0) {
                audioFilters .= ",volume=" . this.volumeBoost . "dB"
            }
            
            audioFilters .= ",compand=.3|.3:1|1:-90/-60|-60/-40|-40/-30|-20/-20:6:0:-90:0.2"
            
            command := A_ComSpec . ' /c ' . piperCmd 
            command .= ' | "' . this.ffmpegPath . '" -f s16le -ar 22050 -ch_layout mono -i - -af "' . audioFilters . '" "' . outputFile . '"'
        } else {
            command := A_ComSpec . ' /c ' . piperCmd
            command .= ' | "' . this.ffmpegPath . '" -f s16le -ar 22050 -ch_layout mono -i - "' . outputFile . '"'
        }
        
        return command
    }
    
    ; Get current executable paths for diagnostic purposes
    GetExecutablePaths() {
        return {
            piper: this.piperPath,
            ffmpeg: this.ffmpegPath,
            ffplay: this.ffplayPath
        }
    }
    
    ; Validate that all paths exist
    ValidatePaths() {
        paths := this.GetExecutablePaths()
        
        missingPaths := []
        for name, path in paths.OwnProps() {
            if (!FileExist(path)) {
                missingPaths.Push(name . ": " . path)
            }
        }
        
        return {
            valid: missingPaths.Length = 0,
            missing: missingPaths
        }
    }
}

--- File: .\DependencyChecker.ahk

; DependencyChecker.ahk - Checks for required executables (ffmpeg and piper)
#Requires AutoHotkey v2

class DependencyChecker {
    
    __New() {
        this.requiredDependencies := [
            {name: "piper", exeName: "piper.exe", localPath: ".\piper\piper.exe",
             downloadUrl: "https://github.com/rhasspy/piper/releases/download/2023.11.14-2/piper_windows_amd64.zip",
             extractPath: ".\piper"},
            {name: "ffmpeg", exeName: "ffmpeg.exe", localPath: ".\ffmpeg\bin\ffmpeg.exe", 
             downloadUrl: "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.7z",
             extractPath: ".\ffmpeg"},
            {name: "ffplay", exeName: "ffplay.exe", localPath: ".\ffmpeg\bin\ffplay.exe",
             downloadUrl: "", extractPath: ""}  ; ffplay comes with ffmpeg
        ]
        this.dependencyStatus := Map()
        this.downloadInProgress := false
    }
    
    ; Main method to check all dependencies
    CheckAllDependencies() {
        missingDependencies := []
        
        for dependency in this.requiredDependencies {
            status := this.CheckSingleDependency(dependency)
            this.dependencyStatus[dependency.name] := status
            
            if (!status.found) {
                missingDependencies.Push(dependency.name)
            }
        }
        
        if (missingDependencies.Length > 0) {
            this.ShowDependencyError(missingDependencies)
            return false
        }
        
        return true
    }
    
    ; Check a single dependency
    CheckSingleDependency(dependency) {
        status := {
            found: false,
            location: "",
            type: "" ; "local" or "system"
        }
        
        ; First check local path
        if (FileExist(dependency.localPath)) {
            status.found := true
            status.location := dependency.localPath
            status.type := "local"
            return status
        }
        
        ; If not found locally, check system PATH
        systemPath := this.FindInSystemPath(dependency.exeName)
        if (systemPath != "") {
            status.found := true
            status.location := systemPath
            status.type := "system"
            return status
        }
        
        return status
    }
    
    ; Search for executable in system PATH
    FindInSystemPath(exeName) {
        ; Get PATH environment variable
        try {
            pathVar := EnvGet("PATH")
        } catch {
            return ""
        }
        
        ; Split PATH by semicolons and check each directory
        pathDirs := StrSplit(pathVar, ";")
        
        for dir in pathDirs {
            if (dir = "") {
                continue
            }
            
            ; Clean up the directory path
            cleanDir := Trim(dir, ' "')
            if (!InStr(cleanDir, "\") && cleanDir != "") {
                cleanDir := cleanDir . "\"
            } else if (SubStr(cleanDir, -1) != "\") {
                cleanDir := cleanDir . "\"
            }
            
            fullPath := cleanDir . exeName
            
            if (FileExist(fullPath)) {
                return fullPath
            }
        }
        
        ; Also check common installation paths
        try {
            ; Get Program Files paths using environment variables
            programFiles := EnvGet("ProgramFiles")
            programW6432 := ""
            try {
                programW6432 := EnvGet("ProgramW6432")  ; 64-bit Program Files on 64-bit systems
            } catch {
                ; ProgramW6432 may not exist on 32-bit systems
            }
            
            commonPaths := [
                programFiles . "\FFmpeg\bin\" . exeName,
                programFiles . "\Piper\" . exeName
            ]
            
            ; Add 64-bit Program Files path if it exists and is different
            if (programW6432 != "" && programW6432 != programFiles) {
                commonPaths.Push(programW6432 . "\FFmpeg\bin\" . exeName)
                commonPaths.Push(programW6432 . "\Piper\" . exeName)
            }
            
            for path in commonPaths {
                if (FileExist(path)) {
                    return path
                }
            }
        } catch {
            ; If environment variable access fails, try A_ProgramFiles fallback
            commonPaths := [
                A_ProgramFiles . "\FFmpeg\bin\" . exeName,
                A_ProgramFiles . "\Piper\" . exeName
            ]
            
            for path in commonPaths {
                if (FileExist(path)) {
                    return path
                }
            }
        }
        
        return ""
    }
    
    ; Test if executable actually works
    TestExecutable(dependency) {
        status := this.dependencyStatus[dependency.name]
        
        if (!status.found) {
            return false
        }
        
        try {
            ; Test the executable with a simple command
            if (dependency.name = "piper") {
                ; Test piper with --help flag
                RunWait('"' . status.location . '" --help', , "Hide")
            } else if (dependency.name = "ffmpeg" || dependency.name = "ffplay") {
                ; Test ffmpeg/ffplay with -version flag
                RunWait('"' . status.location . '" -version', , "Hide")
            }
            return true
        } catch {
            return false
        }
    }
    
    ; Show detailed error message for missing dependencies
    ShowDependencyError(missingDependencies) {
        ; Check if we can auto-download (works for ffmpeg and piper)
        ;canAutoDownload := this.ArrayContains(missingDependencies, "ffmpeg") || this.ArrayContains(missingDependencies, "ffplay") || this.ArrayContains(missingDependencies, "piper")
        
        errorMsg := "‚ùå Missing Required Dependencies:`n`n"
        
        for depName in missingDependencies {
            errorMsg .= "‚Ä¢ " . depName . "`n"
        }
        
        errorMsg .= "`nüìÅ Required Local Paths:`n"
        for dependency in this.requiredDependencies {
            if (this.ArrayContains(missingDependencies, dependency.name)) {
                errorMsg .= "‚Ä¢ " . dependency.localPath . "`n"
            }
        }
        
        errorMsg .= "`nüí° Solutions:`n"
       
        errorMsg .= "1. Download FFmpeg from https://ffmpeg.org/download.html`n"
        
        errorMsg .= "2. Download Piper from https://github.com/rhasspy/piper`n"
        errorMsg .= "3. Extract piper.exe to .\piper\`n"
        
        
            errorMsg .= "`n‚ö†Ô∏è The application requires local installation only."
                    
        MsgBox(errorMsg, "Missing Dependencies", "Iconx")
        ;}
    }
    
    ; Get the effective path for a dependency (local or system)
    GetDependencyPath(dependencyName) {
        if (this.dependencyStatus.Has(dependencyName)) {
            status := this.dependencyStatus[dependencyName]
            if (status.found) {
                return status.location
            }
        }
        return ""
    }
    
    ; Get a summary of all dependency statuses
    GetDependencySummary() {
        summary := "üîç Dependency Status (Local Only):`n`n"
        
        for dependency in this.requiredDependencies {
            status := this.dependencyStatus[dependency.name]
            
            if (status.found) {
                summary .= "‚úÖ " . dependency.name . ": Found`n"
                summary .= "   üìç " . status.location . "`n`n"
            } else {
                summary .= "‚ùå " . dependency.name . ": Not Found`n"
                summary .= "   üìç Expected: " . dependency.localPath . "`n`n"
            }
        }
        
        return summary
    }
    
    ; Helper method to check if array contains a value
    ArrayContains(arr, value) {
        for item in arr {
            if (item = value) {
                return true
            }
        }
        return false
    }
    
    ; Method to update audio settings with dependency paths
    UpdateAudioSettings(audioSettings) {
        ; Update the AudioSettings class to use the found local paths
        piperPath := this.GetDependencyPath("piper")
        ffmpegPath := this.GetDependencyPath("ffmpeg")
        ffplayPath := this.GetDependencyPath("ffplay")
        
        if (piperPath != "" && ffmpegPath != "" && ffplayPath != "") {
            audioSettings.SetExecutablePaths(piperPath, ffmpegPath, ffplayPath)
            return true
        }
        
        return false
    }
}


--- File: .\Highlighter.ahk

#Requires AutoHotkey v2

class Highlighter {
    static guis := []

    static Highlight(x?, y?, w?, h?, showTime:=0, color:="Red", d:=2) {
        if !IsSet(x) {
            for _, r in this.guis
                r.Destroy()
            this.guis := []
            return
        }

        if !this.guis.Length {
            Loop 4
                this.guis.Push(Gui("+AlwaysOnTop -Caption +ToolWindow -DPIScale +E0x08000000"))
        }

        Loop 4 {
            i := A_Index
            x1 := (i=2 ? x+w : x-d)
            y1 := (i=3 ? y+h : y-d)
            w1 := (i=1 or i=3 ? w+2*d : d)
            h1 := (i=2 or i=4 ? h+2*d : d)
            this.guis[i].BackColor := color
            this.guis[i].Show("NA x" . x1 . " y" . y1 . " w" . w1 . " h" . h1)
        }

        if showTime > 0 {
            Sleep(showTime)
            this.Highlight()
        } else if showTime < 0
            SetTimer(() => this.Highlight(), -Abs(showTime))
    }
} 

--- File: .\HotkeyManager.ahk

class HotkeyManager {
    
    __New(ttsPlayer, ocrHandler, uiManager) {
        this.ttsPlayer := ttsPlayer
        this.ocrHandler := ocrHandler
        this.uiManager := uiManager
        this.SetupHotkeys()
    }
    
    SetupHotkeys() {
        ; Stop playback hotkey
        HotKey("CapsLock & s", ObjBindMethod(this, "OnStopHotkey"))
        
        ; Copy and play hotkey
        HotKey("CapsLock & c", ObjBindMethod(this, "OnCopyAndPlayHotkey"))
        
        ; OCR and play hotkey
        HotKey("CapsLock & x", ObjBindMethod(this, "OnOCRAndPlayHotkey"))
    }
    
    OnStopHotkey(*) {
        this.ttsPlayer.StopPlayback(this.uiManager.controls.statusLabel, 
                                   this.uiManager.controls.playButton, this.uiManager.controls.stopButton)
    }
    
    OnCopyAndPlayHotkey(*) {
        oldClipboard := A_Clipboard
        A_Clipboard := ""
        Send("^c")
        
        if (!ClipWait(1)) {
            MsgBox("No text was selected.", "Copy Failed", "Iconx")
            A_Clipboard := oldClipboard
            return
        }
        
        copiedText := A_Clipboard
        A_Clipboard := oldClipboard
        
        if (copiedText = "" || StrLen(Trim(copiedText)) = 0) {
            MsgBox("No text was copied.", "No Text", "Iconx")
            return
        }
        
        textBox := this.uiManager.GetTextBox()
        textBox.Text := copiedText
        this.uiManager.OnPlayText()
    }
    
    OnOCRAndPlayHotkey(*) {
        textBox := this.uiManager.GetTextBox()
        if (this.ocrHandler.StartOCR(textBox)) {
            this.uiManager.OnPlayText()
        }
    }
} 

--- File: .\RectangleCreator.ahk

#Requires AutoHotkey v2

class Rectangle_creator {
    ; Initialize global variables
    coord_1 := [0,0]
    coord_2 := [0,0]
    isFirstCoord := true
    isBoxActive := false
    g_CurrentText := ""
    rectangle := [0,0,0,0]

    get_coord() {
        MouseGetPos(&x, &y)
        return [x, y]
    }

    set_first_coord() {
        this.coord_1 := this.get_coord()
        return this.coord_1
    }

    set_second_coord() {
        this.coord_2 := this.get_coord()
        return this.coord_2
    }

    set_rectangle() {
        this.rectangle := [
            Min(this.coord_1[1], this.coord_2[1]), 
            Min(this.coord_1[2], this.coord_2[2]), 
            Abs(this.coord_2[1] - this.coord_1[1]), 
            Abs(this.coord_2[2] - this.coord_1[2])
        ]
        return this.rectangle
    }
} 

--- File: .\TTSPlayer.ahk

class TTSPlayer {
    
    __New(audioSettings, voiceManager) {
        this.audioSettings := audioSettings
        this.voiceManager := voiceManager
        this.currentProcessPID := 0
        this.tempTextFile := ""
        this.tempAudioFile := ""
        this.playbackTimer := ObjBindMethod(this, "CheckPlaybackStatus")
        this.tooltipTimer := ObjBindMethod(this, "UpdateSentenceTooltip")
        this.sentences := []
        this.currentSentenceIndex := 0
        this.isPlayingSentences := false
    }
    
    PlayText(textBox, voiceDropdown, statusLabel, playButton, stopButton) {
        textToSpeak := textBox.Text
        
        if (textToSpeak = "") {
            MsgBox("Please enter some text to speak.", "No Text", "Iconx")
            statusLabel.Text := "‚ùå No text entered"
            return false
        }
        
        voice := this.voiceManager.GetSelectedVoice(voiceDropdown)
        if (!voice.valid) {
            MsgBox("Please select a valid voice from the dropdown.", "Invalid Voice", "Iconx")
            statusLabel.Text := "‚ùå Invalid voice"
            return false
        }
        
        if (this.currentProcessPID != 0) {
            this.StopPlayback(statusLabel, playButton, stopButton)
        }
        
        this.CleanupTempFiles()
        
        ; Split text into sentences
        this.sentences := this.SplitTextIntoSentences(textToSpeak)
        if (this.sentences.Length = 0) {
            MsgBox("No sentences found in the text.", "No Sentences", "Iconx")
            statusLabel.Text := "‚ùå No sentences found"
            return false
        }
        ; Filter sentences by word count
        this.sentences := this.CombineShortSentences(this.sentences)
        if (this.sentences.Length = 0) {
            MsgBox("No sentences meet the word count criteria.", "No Valid Sentences", "Iconx")
            statusLabel.Text := "‚ùå No valid sentences"
            return false
        }
        this.currentSentenceIndex := 1
        this.isPlayingSentences := true
        playButton.Enabled := true
        playButton.Text := "‚ñ∂ Play"
        stopButton.Enabled := true
        statusText := "üéµ Playing: " . StrSplit(voice.display, "(")[1]
        statusText .= " (" . Round(this.audioSettings.speechSpeed, 1) . "x"
        if (this.audioSettings.useAudioEnhancement) {
            statusText .= ", Enhanced"
        }
        statusText .= ", " . this.sentences.Length . " sentences)"
        statusLabel.Text := statusText
        this.PlayNextSentence(voice, statusLabel, playButton, stopButton)
        return true
    }
    
    PlayNextSentence(voice, statusLabel, playButton, stopButton) {
        if (!this.isPlayingSentences || this.currentSentenceIndex > this.sentences.Length) {
            this.FinishSentencePlayback(statusLabel, playButton, stopButton)
            return
        }
        currentSentence := this.sentences[this.currentSentenceIndex]
        this.tempTextFile := A_Temp . "\piper_sentence_" . A_TickCount . ".txt"
        try {
            FileAppend(currentSentence, this.tempTextFile, "UTF-8")
        } catch as e {
            MsgBox("Failed to create temporary file: " . e.Message, "File Error", "Iconx")
            statusLabel.Text := "‚ùå File error"
            this.FinishSentencePlayback(statusLabel, playButton, stopButton)
            return
        }
        command := this.audioSettings.BuildAudioCommand(voice.file, this.tempTextFile)
        SetTimer(this.tooltipTimer, 50)
        try {
            Run(command, , "Hide", &this.currentProcessPID)
            SetTimer(this.playbackTimer, 250)
        } catch as e {
            MsgBox("Failed to start playback: " . e.Message, "Playback Error", "Iconx")
            this.CleanupTempFiles()
            this.FinishSentencePlayback(statusLabel, playButton, stopButton)
        }
    }
    
    FinishSentencePlayback(statusLabel, playButton, stopButton) {
        this.isPlayingSentences := false
        this.currentSentenceIndex := 0
        this.sentences := []
        statusLabel.Text := "‚úÖ Playback completed"
        this.ResetPlaybackState(playButton, stopButton)
        ToolTip()
        this.CleanupTempFiles()
    }
    
    SplitTextIntoSentences(text) {
        finalSentences := []
        if (Trim(text) = "") {
            return finalSentences
        }
        tempText := StrReplace(text, "`r`n", "`n")
        delimiter := "|~|"
        tempText := StrReplace(tempText, ".", "." . delimiter)
        tempText := StrReplace(tempText, "!", "!" . delimiter)
        tempText := StrReplace(tempText, "?", "?" . delimiter)
        tempText := StrReplace(tempText, "`n", delimiter)
        initialChunks := StrSplit(tempText, delimiter)
        for chunk in initialChunks {
            if (Trim(chunk) = "") {
                continue
            }
            finalSentences.Push(Trim(chunk))
        }
        return finalSentences
    }
    
    CombineShortSentences(sentences) {
        combinedSentences := []
        i := 1
        
        while (i <= sentences.Length) {
            currentSentence := Trim(sentences[i])
            
            ; Skip completely empty sentences
            if (currentSentence = "") {
                i++
                continue
            }
            
            ; Count words in current sentence
            wordCount := StrSplit(currentSentence, [" ", A_Tab]).Length
            
            ; If sentence is too short, try to combine with next sentences
            while (wordCount < this.audioSettings.minWordsPerSentence && i < sentences.Length) {
                i++
                nextSentence := Trim(sentences[i])
                if (nextSentence != "") {
                    currentSentence .= " " . nextSentence
                    wordCount := StrSplit(currentSentence, [" ", A_Tab]).Length
                }
            }
            
            combinedSentences.Push(currentSentence)
            i++
        }
        
        return combinedSentences
    }
    
    SaveAudio(textBox, voiceDropdown, statusLabel) {
        textToSpeak := textBox.Text
        
        if (textToSpeak = "") {
            MsgBox("Please enter some text to save as audio.", "No Text", "Iconx")
            statusLabel.Text := "‚ùå No text to save"
            return false
        }
        
        voice := this.voiceManager.GetSelectedVoice(voiceDropdown)
        if (!voice.valid) {
            MsgBox("Please select a valid voice from the dropdown.", "Invalid Voice", "Iconx")
            statusLabel.Text := "‚ùå Invalid voice"
            return false
        }
        
        saveFile := FileSelect("S", "piper_audio.wav", "Save Audio File", "Wave Files (*.wav)")
        if (saveFile = "") {
            return false
        }
        
        this.CleanupTempFiles()
        
        this.tempTextFile := A_Temp . "\piper_text_" . A_TickCount . ".txt"
        
        try {
            FileAppend(textToSpeak, this.tempTextFile, "UTF-8")
        } catch as e {
            MsgBox("Failed to create temporary file: " . e.Message, "File Error", "Iconx")
            statusLabel.Text := "‚ùå File error"
            return false
        }
        
        command := this.audioSettings.BuildSaveCommand(voice.file, this.tempTextFile, saveFile)
        
        statusLabel.Text := "üíæ Saving audio file..."
        
        try {
            RunWait(command, , "Hide")
            statusLabel.Text := "‚úÖ Audio saved: " . saveFile
            MsgBox("Audio saved successfully!", "Save Complete", "Iconi")
            this.CleanupTempFiles()
            return true
        } catch as e {
            MsgBox("Failed to save audio: " . e.Message, "Save Error", "Iconx")
            statusLabel.Text := "‚ùå Failed to save"
            this.CleanupTempFiles()
            return false
        }
    }
    
    StopPlayback(statusLabel, playButton, stopButton) {
        if (this.currentProcessPID = 0) {
            return
        }
        this.isPlayingSentences := false
        try {
            RunWait('taskkill /F /T /PID ' . this.currentProcessPID, , "Hide")
            statusLabel.Text := "‚èπ Playback stopped"
        } catch as e {
            try {
                ProcessClose(this.currentProcessPID)
                statusLabel.Text := "‚èπ Playback stopped"
            } catch {
                statusLabel.Text := "‚ùå Failed to stop"
            }
        }
        this.ResetPlaybackState(playButton, stopButton)
        ToolTip()
        this.CleanupTempFiles()
    }
    
    CheckPlaybackStatus() {
        if (this.currentProcessPID = 0) {
            SetTimer(this.playbackTimer, 0)
            return
        }
        if (!ProcessExist(this.currentProcessPID)) {
            if (this.isPlayingSentences) {
                this.currentSentenceIndex++
                SetTimer(this.playbackTimer, 0)
                SetTimer(this.tooltipTimer, 0)
                this.currentProcessPID := 0
                try {
                    voice := piperApp.voiceManager.GetSelectedVoice(piperApp.uiManager.controls.voiceDropdown)
                    if (voice.valid) {
                        this.PlayNextSentence(voice, piperApp.uiManager.controls.statusLabel, piperApp.uiManager.controls.playButton, piperApp.uiManager.controls.stopButton)
                    }
                } catch {
                    this.FinishSentencePlayback("", "", "")
                }
            } else {
                this.ResetPlaybackState()
                ToolTip()
                this.CleanupTempFiles()
            }
        }
    }
    
    ResetPlaybackState(playButton?, stopButton?) {
        SetTimer(this.tooltipTimer, 0)
        SetTimer(this.playbackTimer, 0)
        this.currentProcessPID := 0
        ToolTip()
        
        if (IsSet(playButton)) {
            playButton.Enabled := true
            playButton.Text := "‚ñ∂ Play"
        }
        if (IsSet(stopButton)) {
            stopButton.Enabled := false
        }
    }
    
    UpdateSentenceTooltip() {
        if (this.currentProcessPID != 0 && this.isPlayingSentences && this.currentSentenceIndex > 0 && this.currentSentenceIndex <= this.sentences.Length) {
            MouseGetPos(&mouseX, &mouseY)
            currentSentence := this.sentences[this.currentSentenceIndex]
            ToolTip(currentSentence, mouseX + 15, mouseY - 30)
        }
    }
    
    CleanupTempFiles() {
        if (this.tempTextFile != "") {
            try {
                if (FileExist(this.tempTextFile)) {
                    FileDelete(this.tempTextFile)
                }
            } catch {
                ; Ignore errors
            }
        }
        
        if (this.tempAudioFile != "") {
            try {
                if (FileExist(this.tempAudioFile)) {
                    FileDelete(this.tempAudioFile)
                }
            } catch {
                ; Ignore errors
            }
        }
    }
    
    Cleanup() {
        if (this.currentProcessPID != 0) {
            try {
                ProcessClose(this.currentProcessPID)
            } catch {
                ; Ignore errors
            }
        }
        this.CleanupTempFiles()
    }
} 

--- File: .\UIManager.ahk

; Updated UIManager.ahk - Now includes dependency information feature
#Requires AutoHotkey v2

class UIManager {
    
    __New(piperApp, audioSettings, voiceManager, ttsPlayer, ocrHandler) {
        this.app := piperApp
        this.audioSettings := audioSettings
        this.voiceManager := voiceManager
        this.ttsPlayer := ttsPlayer
        this.ocrHandler := ocrHandler
        this.gui := ""
        this.controls := {}
       
       ; Language maps for UI text
       this.englishMap := Map(
           "playButton", "‚ñ∂ Play",
           "stopButton", "‚èπ Stop",
           "refreshButton", "‚Üª",
           "voicesButton", "üìÅ",
           "languageGroup", "Language",
           "voiceGroup", "Voice Selection",
           "audioGroup", "Audio Settings",
           "textGroup", "Text to Speak",
           "controlsGroup", "Controls",
           "enhancedCheckbox", "üîä Enhanced",
           "speedLabel", "Speed:",
           "slowLabel", "Slow",
           "fastLabel", "Fast",
           "volumeLabel", "Volume:",
           "quietLabel", "Quiet",
           "loudLabel", "Loud",
           "dbLabel", "dB",
           "readyStatus", "Ready",
           "hintsText", "üí° Hotkeys: CapsLock+C (Copy & Play) ‚Ä¢ CapsLock+X (OCR & Play) ‚Ä¢ CapsLock+S (Stop)",
           "defaultText", "Enhanced Piper TTS with object-oriented design and improved maintainability.",
           "saveAudioMenu", "üíæ &Save Audio",
           "dependenciesMenu", "‚ÑπÔ∏è &Dependencies",
           "helpMenu", "‚ùì &Help",
           "aboutMenu", "‚ÑπÔ∏è &About",
           "exitMenu", "‚úñÔ∏è &Exit",
           "voiceRefreshed", "Voice list refreshed",
           "voicesFolderOpened", "Opened voices folder",
           "voicesFolderNotFound", "Voices folder not found!",
           "audioEnhancementEnabled", "Audio enhancement enabled",
           "audioEnhancementDisabled", "Audio enhancement disabled",
           "invalidSpeed", "‚ùå Invalid speed: Not a number",
           "speedSet", "Speed set to",
           "invalidVolume", "‚ùå Invalid volume: Not a number",
           "volumeSet", "Volume set to",
           "invalidSpeedInput", "‚ùå Invalid speed input",
           "invalidVolumeInput", "‚ùå Invalid volume input",
           "ocrSelectArea", "Select area for OCR...",
           "languageChangedTo", "Language changed to",
           "invalidSpeedTitle", "Invalid Speed",
           "invalidVolumeTitle", "Invalid Volume",
           "invalidSpeedMessage", "Please enter a valid number for speed.",
           "invalidVolumeMessage", "Please enter a valid number for volume.",
           "errorTitle", "Error",
           "minWordsLabel", "Min:",
           "minWordsInput", "Min words:",
           "maxWordsLabel", "Max:",
           "maxWordsInput", "Max words:",
           "invalidMinWords", "‚ùå Invalid min words: Not a number",
           "minWordsSet", "Min words set to",
           "invalidMaxWords", "‚ùå Invalid max words: Not a number",
           "maxWordsSet", "Max words set to"
       )
       
       this.arabicMap := Map(
           "playButton", "‚ñ∂ ÿ™ÿ¥ÿ∫ŸäŸÑ",
           "stopButton", "‚èπ ÿ•ŸäŸÇÿßŸÅ",
           "refreshButton", "‚Üª",
           "voicesButton", "üìÅ",
           "languageGroup", "ÿßŸÑŸÑÿ∫ÿ©",
           "voiceGroup", "ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿµŸàÿ™",
           "audioGroup", "ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿµŸàÿ™",
           "textGroup", "ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿ±ÿßÿØ ŸÇÿ±ÿßÿ°ÿ™Ÿá",
           "controlsGroup", "ÿßŸÑÿ™ÿ≠ŸÉŸÖ",
           "enhancedCheckbox", "üîä ŸÖÿ≠ÿ≥ŸÜ",
           "speedLabel", "ÿßŸÑÿ≥ÿ±ÿπÿ©:",
           "slowLabel", "ÿ®ÿ∑Ÿäÿ°",
           "fastLabel", "ÿ≥ÿ±Ÿäÿπ",
           "volumeLabel", "ÿßŸÑÿµŸàÿ™:",
           "quietLabel", "ŸáÿßÿØÿ¶",
           "loudLabel", "ÿπÿßŸÑŸä",
           "dbLabel", "ÿØŸäÿ≥Ÿäÿ®ŸÑ",
           "readyStatus", "ÿ¨ÿßŸáÿ≤",
           "hintsText", "üí° ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑŸÖÿÆÿ™ÿµÿ±ÿ©: CapsLock+C (ŸÜÿ≥ÿÆ Ÿàÿ™ÿ¥ÿ∫ŸäŸÑ) ‚Ä¢ CapsLock+X (OCR Ÿàÿ™ÿ¥ÿ∫ŸäŸÑ) ‚Ä¢ CapsLock+S (ÿ•ŸäŸÇÿßŸÅ)",
           "defaultText", "ŸÖÿ≠ÿ±ŸÉ Piper TTS ÿßŸÑŸÖÿ≠ÿ≥ŸÜ ŸÖÿπ ÿ™ÿµŸÖŸäŸÖ ÿ¥Ÿäÿ¶Ÿä ŸàŸÖÿ±ŸàŸÜÿ© ŸÖÿ≠ÿ≥ŸÜÿ© ŸÅŸä ÿßŸÑÿµŸäÿßŸÜÿ©.",
           "saveAudioMenu", "üíæ &ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ™",
           "dependenciesMenu", "‚ÑπÔ∏è &ÿßŸÑÿ™ÿ®ÿπŸäÿßÿ™",
           "helpMenu", "‚ùì &ŸÖÿ≥ÿßÿπÿØÿ©",
           "aboutMenu", "‚ÑπÔ∏è &ÿ≠ŸàŸÑ",
           "exitMenu", "‚úñÔ∏è &ÿÆÿ±Ÿàÿ¨",
           "voiceRefreshed", "ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ÿµŸàÿßÿ™",
           "voicesFolderOpened", "ÿ™ŸÖ ŸÅÿ™ÿ≠ ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿµŸàÿßÿ™",
           "voicesFolderNotFound", "ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿµŸàÿßÿ™!",
           "audioEnhancementEnabled", "ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿµŸàÿ™",
           "audioEnhancementDisabled", "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿµŸàÿ™",
           "invalidSpeed", "‚ùå ÿ≥ÿ±ÿπÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©: ŸÑŸäÿ≥ ÿ±ŸÇŸÖÿßŸã",
           "speedSet", "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ≥ÿ±ÿπÿ© ÿ•ŸÑŸâ",
           "invalidVolume", "‚ùå ŸÖÿ≥ÿ™ŸàŸâ ÿµŸàÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠: ŸÑŸäÿ≥ ÿ±ŸÇŸÖÿßŸã",
           "volumeSet", "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™ ÿ•ŸÑŸâ",
           "invalidSpeedInput", "‚ùå ÿ•ÿØÿÆÿßŸÑ ÿ≥ÿ±ÿπÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠",
           "invalidVolumeInput", "‚ùå ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≥ÿ™ŸàŸâ ÿµŸàÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠",
           "ocrSelectArea", "ÿ≠ÿØÿØ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ŸÑŸÄ OCR...",
           "languageChangedTo", "ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÑÿ∫ÿ© ÿ•ŸÑŸâ",
           "invalidSpeedTitle", "ÿ≥ÿ±ÿπÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©",
           "invalidVolumeTitle", "ŸÖÿ≥ÿ™ŸàŸâ ÿµŸàÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠",
           "invalidSpeedMessage", "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ŸÑŸÑÿ≥ÿ±ÿπÿ©.",
           "invalidVolumeMessage", "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ŸÇŸÖ ÿµÿ≠Ÿäÿ≠ ŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµŸàÿ™.",
           "errorTitle", "ÿÆÿ∑ÿ£",
           "minWordsLabel", "ÿ£ÿØŸÜŸâ:",
           "minWordsInput", "ÿ£ÿØŸÜŸâ ŸÉŸÑŸÖÿßÿ™:",
           "maxWordsLabel", "ÿ£ÿπŸÑŸâ:",
           "maxWordsInput", "ÿ£ÿπŸÑŸâ ŸÉŸÑŸÖÿßÿ™:",
           "invalidMinWords", "‚ùå ÿ£ÿØŸÜŸâ ŸÉŸÑŸÖÿßÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠: ŸÑŸäÿ≥ ÿ±ŸÇŸÖÿßŸã",
           "minWordsSet", "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿ£ÿØŸÜŸâ ŸÉŸÑŸÖÿßÿ™ ÿ•ŸÑŸâ",
           "invalidMaxWords", "‚ùå ÿ£ÿπŸÑŸâ ŸÉŸÑŸÖÿßÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠: ŸÑŸäÿ≥ ÿ±ŸÇŸÖÿßŸã",
           "maxWordsSet", "ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿ£ÿπŸÑŸâ ŸÉŸÑŸÖÿßÿ™ ÿ•ŸÑŸâ"
       )
    }
    
    CreateGUI() {
        this.gui := Gui("+Resize -MaximizeBox", "PiperAnywhere")
        this.gui.MarginX := 8
        this.gui.MarginY := 8
        this.gui.SetFont("s9", "Segoe UI")
        
        ; Create a MenuBar and a File menu
        this.menuBar := MenuBar()
        this.fileMenu := Menu()
        this.menuBar.Add("&File", this.fileMenu)
        this.gui.MenuBar := this.menuBar
        
        ; Language section (New)
        this.CreateLanguageSection()
        
        ; Voice section
        this.CreateVoiceSection()
        
        ; Audio settings section
        this.CreateAudioSection()
        
        ; Text input section
        this.CreateTextSection()
        
        ; Control buttons
        this.CreateControlButtons()
        
        ; Status and hints
        this.CreateStatusSection()
        
        ; Set up event handlers
        this.SetupEventHandlers()
        
        ; Store references for easy access
        this.voiceDropdown := this.controls.voiceDropdown
        this.statusLabel := this.controls.statusLabel
        
        ; Add menu items to the File menu
        this.CreateMenuItems()
    }
    
    CreateLanguageSection() {
        this.controls.languageGroup := this.gui.AddGroupBox("x8 y8 w280 h50", this.GetText("languageGroup"))
        this.controls.languageGroup.SetFont("s8 Bold", "Segoe UI")
        this.controls.languageDropdown := this.gui.AddDropDownList("x16 y26 w200 h200", ["English", "Arabic"])
        this.controls.languageDropdown.Choose(1)
       
       ; Set up language change event handler
       this.controls.languageDropdown.OnEvent("Change", ObjBindMethod(this, "OnLanguageChanged"))
    }
    
    CreateVoiceSection() {
        this.controls.voiceGroup := this.gui.AddGroupBox("x8 y66 w280 h50", this.GetText("voiceGroup"))
        this.controls.voiceGroup.SetFont("s8 Bold", "Segoe UI")
        
        this.controls.voiceDropdown := this.gui.AddDropDownList("x16 y84 w200 h200", [])
        this.controls.refreshButton := this.gui.AddButton("x220 y84 w25 h21", this.GetText("refreshButton"))
        this.controls.refreshButton.SetFont("s8")
        
        this.controls.voicesButton := this.gui.AddButton("x248 y84 w32 h21", this.GetText("voicesButton"))
        this.controls.voicesButton.SetFont("s8")
    }
    
    CreateAudioSection() {
        this.controls.audioGroup := this.gui.AddGroupBox("x8 y124 w280 h110", this.GetText("audioGroup"))
        this.controls.audioGroup.SetFont("s8 Bold", "Segoe UI")
        
        ; Enhancement toggle
        this.controls.enhancementCheckbox := this.gui.AddCheckbox("x16 y142 w90 h16 Checked", this.GetText("enhancedCheckbox"))
        this.controls.enhancementCheckbox.SetFont("s8")
        
        ; Speed control
        this.controls.speedLabel := this.gui.AddText("x16 y162 w25", this.GetText("speedLabel"))
        this.controls.slowLabel := this.gui.AddText("x+6 y162 w35", this.GetText("slowLabel"))
        this.controls.speedSlider := this.gui.AddSlider("x100 y160 w60 h20 Range50-200 NoTicks", 100)
        this.controls.fastLabel := this.gui.AddText("x+6 y162 w25", this.GetText("fastLabel"))
        this.controls.speedInput := this.gui.AddEdit("x+6 y162 w30 h16", "1.0")
        this.controls.speedInput.SetFont("s8 Bold")
        
        ; Volume control
        this.controls.volumeLabel := this.gui.AddText("x16 y178", this.GetText("volumeLabel"))
        this.controls.quietLabel := this.gui.AddText("x+3 y178", this.GetText("quietLabel"))
        this.controls.volumeSlider := this.gui.AddSlider("x100 y176 w60 h20 Range-10-20 NoTicks", 2)
        this.controls.loudLabel := this.gui.AddText("x+6 y178 w30 h16", this.GetText("loudLabel"))
        this.controls.volumeInput := this.gui.AddEdit("x+6 y178 w30 h16", "2")
        this.controls.volumeInput.SetFont("s8 Bold")
        this.controls.dbLabel := this.gui.AddText("x+6 y178 w30 h16", this.GetText("dbLabel"))
        
        ; Word count controls
        this.controls.minWordsLabel := this.gui.AddText("x16 y194 w40", this.GetText("minWordsLabel"))
        this.controls.minWordsInput := this.gui.AddEdit("x+6 y194 w30 h16", "6")
        this.controls.minWordsInput.SetFont("s8 Bold")
        this.controls.maxWordsLabel := this.gui.AddText("x+6 y194 w40", this.GetText("maxWordsLabel"))
        this.controls.maxWordsInput := this.gui.AddEdit("x+6 y194 w30 h16", "25")
        this.controls.maxWordsInput.SetFont("s8 Bold")
    }
    
    CreateTextSection() {
        this.controls.textGroup := this.gui.AddGroupBox("x8 y215 w280 h80", this.GetText("textGroup"))
        this.controls.textGroup.SetFont("s8 Bold", "Segoe UI")
        
        this.controls.textBox := this.gui.AddEdit("x16 y235 w264 h54 VScroll", 
                                            this.GetText("defaultText"))
    }
    
    CreateControlButtons() {
        this.controls.buttonGroup := this.gui.AddGroupBox("x8 y290 w280 h60", this.GetText("controlsGroup"))
        this.controls.buttonGroup.SetFont("s8 Bold", "Segoe UI")
        
        ; First row of buttons
       this.controls.playButton := this.gui.AddButton("x16 y308 w50 h24 Default", this.GetText("playButton"))
        this.controls.playButton.SetFont("s8 Bold")
        
        this.controls.stopButton := this.gui.AddButton("x70 y308 w50 h24 Disabled", this.GetText("stopButton"))
        this.controls.stopButton.SetFont("s8 Bold")
        
        
    }
    
    CreateStatusSection() {
        this.controls.statusLabel := this.gui.AddText("x8 y334 w280 h16 Center", this.GetText("readyStatus"))
        this.controls.statusLabel.SetFont("s8", "Segoe UI")
        
        this.controls.qualityLabel := this.gui.AddText("x8 y350 w280 h16 Center", "")
        this.controls.qualityLabel.SetFont("s7", "Segoe UI")
        
        this.controls.hintLabel := this.gui.AddText("x8 y366 w280 h32 Center", 
                                              this.GetText("hintsText"))
        this.controls.hintLabel.SetFont("s7", "Segoe UI")
    }
    
    CreateMenuItems() {
        this.fileMenu.Add(this.GetText("saveAudioMenu"), ObjBindMethod(this, "OnSaveAudio"))
        this.fileMenu.Add(this.GetText("dependenciesMenu"), ObjBindMethod(this, "OnShowDependencyInfo"))
        this.fileMenu.Add(this.GetText("helpMenu"), ObjBindMethod(this, "OnShowHelp"))
        this.fileMenu.Add(this.GetText("aboutMenu"), ObjBindMethod(this, "OnShowAbout"))
        this.fileMenu.Add(this.GetText("exitMenu"), ObjBindMethod(this, "OnExit"))
    }
    
    SetupEventHandlers() {
        ; Use bound methods to maintain 'this' context
        this.controls.refreshButton.OnEvent("Click", ObjBindMethod(this, "OnRefreshVoices"))
        this.controls.voicesButton.OnEvent("Click", ObjBindMethod(this, "OnOpenVoicesFolder"))
        this.controls.enhancementCheckbox.OnEvent("Click", ObjBindMethod(this, "OnEnhancementToggled"))
        this.controls.speedSlider.OnEvent("Change", ObjBindMethod(this, "OnSpeedChanged"))
        this.controls.speedInput.OnEvent("LoseFocus", ObjBindMethod(this, "OnSpeedInputChanged"))
        this.controls.volumeSlider.OnEvent("Change", ObjBindMethod(this, "OnVolumeChanged"))
        this.controls.volumeInput.OnEvent("LoseFocus", ObjBindMethod(this, "OnVolumeInputChanged"))
        this.controls.playButton.OnEvent("Click", ObjBindMethod(this, "OnPlayText"))
        this.controls.stopButton.OnEvent("Click", ObjBindMethod(this, "OnStopPlayback"))
        this.controls.minWordsInput.OnEvent("LoseFocus", ObjBindMethod(this, "OnMinWordsInputChanged"))
        this.controls.maxWordsInput.OnEvent("LoseFocus", ObjBindMethod(this, "OnMaxWordsInputChanged"))
        
        ; GUI close event
        this.gui.OnEvent("Close", ObjBindMethod(this, "OnExit"))
    }
    
    ; Event handlers
    OnLanguageChanged(*) {
        this.UpdateAllTexts()
        selectedLanguage := this.controls.languageDropdown.Text
        this.controls.statusLabel.Text := this.GetText("languageChangedTo") . " " . selectedLanguage
    }
    
    UpdateAllTexts() {
        ; Update group boxes
        this.controls.languageGroup.Text := this.GetText("languageGroup")
        this.controls.voiceGroup.Text := this.GetText("voiceGroup")
        this.controls.audioGroup.Text := this.GetText("audioGroup")
        this.controls.textGroup.Text := this.GetText("textGroup")
        this.controls.buttonGroup.Text := this.GetText("controlsGroup")
        
        ; Update buttons
        this.controls.playButton.Text := this.GetText("playButton")
        this.controls.stopButton.Text := this.GetText("stopButton")
        this.controls.refreshButton.Text := this.GetText("refreshButton")
        this.controls.voicesButton.Text := this.GetText("voicesButton")
        
        ; Update checkbox
        this.controls.enhancementCheckbox.Text := this.GetText("enhancedCheckbox")
        
        ; Update labels
        this.controls.speedLabel.Text := this.GetText("speedLabel")
        this.controls.slowLabel.Text := this.GetText("slowLabel")
        this.controls.fastLabel.Text := this.GetText("fastLabel")
        this.controls.volumeLabel.Text := this.GetText("volumeLabel")
        this.controls.quietLabel.Text := this.GetText("quietLabel")
        this.controls.loudLabel.Text := this.GetText("loudLabel")
        this.controls.dbLabel.Text := this.GetText("dbLabel")
        
        ; Update hints
        this.controls.hintLabel.Text := this.GetText("hintsText")
        
        ; Update status
        this.controls.statusLabel.Text := this.GetText("readyStatus")
        
        ; Update text box placeholder
        if (this.controls.textBox.Text = this.englishMap["defaultText"] || this.controls.textBox.Text = this.arabicMap["defaultText"]) {
            this.controls.textBox.Text := this.GetText("defaultText")
        }
        
        ; Recreate menu items
        this.fileMenu.Delete()
        this.CreateMenuItems()
        
        ; Update word count labels
        this.controls.minWordsLabel.Text := this.GetText("minWordsLabel")
        this.controls.maxWordsLabel.Text := this.GetText("maxWordsLabel")
    }
    
    OnRefreshVoices(*) {
        this.voiceManager.PopulateVoices(this.controls.voiceDropdown, this.controls.statusLabel)
        this.controls.statusLabel.Text := this.GetText("voiceRefreshed")
    }
    
    OnOpenVoicesFolder(*) {
        if (this.voiceManager.OpenVoicesFolder()) {
            this.controls.statusLabel.Text := this.GetText("voicesFolderOpened")
        } else {
            MsgBox(this.GetText("voicesFolderNotFound"), this.GetText("errorTitle"), "Iconx")
        }
    }
    
    OnEnhancementToggled(*) {
        this.audioSettings.SetEnhancement(this.controls.enhancementCheckbox.Value)
        this.UpdateQualityInfo()
        this.controls.statusLabel.Text := this.audioSettings.useAudioEnhancement ? 
                                        this.GetText("audioEnhancementEnabled") : this.GetText("audioEnhancementDisabled")
    }
    
    OnSpeedChanged(*) {
        speed := this.controls.speedSlider.Value / 100.0
        this.audioSettings.SetSpeed(speed)
        this.controls.speedInput.Text := Round(speed, 2)
    }
    
    OnSpeedInputChanged(*) {
        newSpeed := this.controls.speedInput.Text
        
        if (!this.audioSettings.SetSpeed(newSpeed)) {
            this.controls.statusLabel.Text := this.GetText("invalidSpeed")
            this.controls.speedInput.Text := Round(this.audioSettings.speechSpeed, 2)
            return
        }
        
        this.controls.speedSlider.Value := Round(this.audioSettings.speechSpeed * 100)
        this.controls.statusLabel.Text := this.GetText("speedSet") . " " . Round(this.audioSettings.speechSpeed, 2) . "x"
    }
    
    OnVolumeChanged(*) {
        volume := this.controls.volumeSlider.Value
        this.audioSettings.SetVolume(volume)
        this.controls.volumeInput.Text := volume
    }
    
    OnVolumeInputChanged(*) {
        newVolume := this.controls.volumeInput.Text
        
        if (!this.audioSettings.SetVolume(newVolume)) {
            this.controls.statusLabel.Text := this.GetText("invalidVolume")
            this.controls.volumeInput.Text := this.audioSettings.volumeBoost
            return
        }
        
        this.controls.volumeSlider.Value := Round(this.audioSettings.volumeBoost)
        this.controls.statusLabel.Text := this.GetText("volumeSet") . " " . Round(this.audioSettings.volumeBoost, 1) . this.GetText("dbLabel")
    }
    
    OnPlayText(*) {
        ; Validate inputs before playback
        if (!IsNumber(this.controls.speedInput.Text)) {
            MsgBox(this.GetText("invalidSpeedMessage"), this.GetText("invalidSpeedTitle"), "Iconx")
            this.controls.speedInput.Text := Round(this.audioSettings.speechSpeed, 2)
            this.controls.statusLabel.Text := this.GetText("invalidSpeedInput")
            return
        }
        this.OnSpeedInputChanged()
        
        if (!IsNumber(this.controls.volumeInput.Text)) {
            MsgBox(this.GetText("invalidVolumeMessage"), this.GetText("invalidVolumeTitle"), "Iconx")
            this.controls.volumeInput.Text := this.audioSettings.volumeBoost
            this.controls.statusLabel.Text := this.GetText("invalidVolumeInput")
            return
        }
        this.OnVolumeInputChanged()
        
        this.ttsPlayer.PlayText(this.controls.textBox, this.controls.voiceDropdown, 
                               this.controls.statusLabel, this.controls.playButton, this.controls.stopButton)
    }
    
    OnStopPlayback(*) {
        this.ttsPlayer.StopPlayback(this.controls.statusLabel, this.controls.playButton, this.controls.stopButton)
    }
    
    OnSaveAudio(*) {
        ; Validate inputs before saving
        if (!IsNumber(this.controls.speedInput.Text)) {
            MsgBox(this.GetText("invalidSpeedMessage"), this.GetText("invalidSpeedTitle"), "Iconx")
            this.controls.speedInput.Text := Round(this.audioSettings.speechSpeed, 2)
            this.controls.statusLabel.Text := this.GetText("invalidSpeedInput")
            return
        }
        this.OnSpeedInputChanged()
        
        if (!IsNumber(this.controls.volumeInput.Text)) {
            MsgBox(this.GetText("invalidVolumeMessage"), this.GetText("invalidVolumeTitle"), "Iconx")
            this.controls.volumeInput.Text := this.audioSettings.volumeBoost
            this.controls.statusLabel.Text := this.GetText("invalidVolumeInput")
            return
        }
        this.OnVolumeInputChanged()
        
        this.ttsPlayer.SaveAudio(this.controls.textBox, this.controls.voiceDropdown, this.controls.statusLabel)
    }
    
    OnStartOCR(*) {
        this.controls.statusLabel.Text := this.GetText("ocrSelectArea")
        ; OCR functionality handled by hotkey manager
    }
    
    ; New event handlers
    OnShowDependencyInfo(*) {
        this.app.ShowDependencyInfo()
    }
    
    OnShowHelp(*) {
        helpText := "üéôÔ∏è Piper TTS Help`n`n"
        helpText .= "üìù Basic Usage:`n"
        helpText .= "1. Select a voice from the dropdown`n"
        helpText .= "2. Enter text to speak`n"
        helpText .= "3. Click Play or use hotkeys`n`n"
        helpText .= "‚å®Ô∏è Hotkeys:`n"
        helpText .= "‚Ä¢ CapsLock + C: Copy selected text and play`n"
        helpText .= "‚Ä¢ CapsLock + X: OCR screen area and play`n"
        helpText .= "‚Ä¢ CapsLock + S: Stop playback`n`n"
        helpText .= "üîß Audio Settings:`n"
        helpText .= "‚Ä¢ Enhanced: Better quality with filters`n"
        helpText .= "‚Ä¢ Speed: 0.5x to 2.0x playback speed`n"
        helpText .= "‚Ä¢ Volume: -10dB to +20dB boost`n`n"
        helpText .= "üìÅ Files:`n"
        helpText .= "‚Ä¢ Voices: Place .onnx files in voices folder`n"
        helpText .= "‚Ä¢ Dependencies: FFmpeg and Piper required`n`n"
        helpText .= "‚ÑπÔ∏è Click 'Dependencies' to check installation status."
        
        MsgBox(helpText, "Help - Piper TTS", "Iconi")
    }
    
    OnShowAbout(*) {
        aboutText := "üéôÔ∏è piperAnywhere v1.0`n" .
                    "Text-to-Speech Annotation Tool`n`n" .
                    "Copyright (C) 2025 yousef abdullah`n" .
                    "Licensed under GPL v3.0`n`n" .
                    "Source: https://github.com/yosef0H4/piperanywhere`n`n" .
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`n" .
                    "THIRD-PARTY COMPONENTS:`n`n" .
                    "‚Ä¢ This software uses libraries from the FFmpeg project under the LGPLv2.1`n" .
                    "  Source: https://github.com/FFmpeg/FFmpeg`n" .
                    "  License: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html`n`n" .
                    "‚Ä¢ Piper TTS Engine (MIT License)`n" .
                    "  Source: https://github.com/rhasspy/piper`n`n" .
                    "‚Ä¢ OCR Library by Descolada (MIT License)`n" .
                    "  Source: https://github.com/Descolada/OCR/`n`n" .
                    "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`n" .
                    "For complete license terms, see LICENSE file in same directory."
        
        MsgBox(aboutText, "About piperAnywhere", "Iconi")
    }
    
    OnExit(*) {
        this.app.SaveSettings()
        this.ttsPlayer.Cleanup()
        ExitApp()
    }
    
    UpdateQualityInfo() {
        this.controls.qualityLabel.Text := this.audioSettings.GetQualityDescription()
    }
    
    ShowGUI() {
        this.gui.Show("w296 h418")
    }
    
    GetTextBox() {
        return this.controls.textBox
    }
    
    GetText(key) {
        selectedLanguage := this.controls.HasOwnProp("languageDropdown") ? this.controls.languageDropdown.Text : "English"
        
        if (selectedLanguage = "Arabic") {
            return this.arabicMap[key]
        } else {
            return this.englishMap[key]
        }
    }
    
    OnMinWordsInputChanged(*) {
        newMinWords := this.controls.minWordsInput.Text
        if (!this.audioSettings.SetMinWords(newMinWords)) {
            this.controls.statusLabel.Text := this.GetText("invalidMinWords")
            this.controls.minWordsInput.Text := this.audioSettings.minWordsPerSentence
            return
        }
        this.controls.statusLabel.Text := this.GetText("minWordsSet") . " " . this.audioSettings.minWordsPerSentence
    }
    
    OnMaxWordsInputChanged(*) {
        newMaxWords := this.controls.maxWordsInput.Text
        if (!this.audioSettings.SetMaxWords(newMaxWords)) {
            this.controls.statusLabel.Text := this.GetText("invalidMaxWords")
            this.controls.maxWordsInput.Text := this.audioSettings.maxWordsPerSentence
            return
        }
        this.controls.statusLabel.Text := this.GetText("maxWordsSet") . " " . this.audioSettings.maxWordsPerSentence
    }
    
    LoadSettings() {
        this.audioSettings.SetMinWords(IniRead(this.settingsFile, "Settings", "MinWords", 6))
        this.audioSettings.SetMaxWords(IniRead(this.settingsFile, "Settings", "MaxWords", 25))
        this.controls.minWordsInput.Text := this.audioSettings.minWordsPerSentence
        this.controls.maxWordsInput.Text := this.audioSettings.maxWordsPerSentence
    }
    
    SaveSettings() {
        try {
            IniWrite(this.audioSettings.minWordsPerSentence, this.settingsFile, "Settings", "MinWords")
            IniWrite(this.audioSettings.maxWordsPerSentence, this.settingsFile, "Settings", "MaxWords")
        } catch as err {
            ; Optional: MsgBox("Error saving settings: " . err.Message, "Save Error", "Iconx")
        }
    }
}

--- File: .\VoiceManager.ahk

class VoiceManager {
    
    __New() {
        this.voices := []
        this.voicesPath := ".\voices\*.onnx"
    }
    
    PopulateVoices(dropdown, statusLabel) {
        this.voices := []
        dropdown.Delete()
        
        if (!DirExist(".\voices")) {
            dropdown.Add(["‚ùå No voices directory"])
            dropdown.Choose(1)
            statusLabel.Text := "‚ö†Ô∏è Voices directory not found"
            return false
        }
        
        Loop Files, this.voicesPath {
            cleanName := StrReplace(A_LoopFileName, ".onnx", "")
            cleanName := StrReplace(cleanName, "_", " ")
            displayName := cleanName . " (" . A_LoopFileName . ")"
            this.voices.Push({display: displayName, file: A_LoopFileName})
        }
        
        if (this.voices.Length = 0) {
            dropdown.Add(["‚ùå No voices found"])
            dropdown.Choose(1)
            statusLabel.Text := "‚ö†Ô∏è No .onnx files found"
            return false
        }
        
        voiceList := []
        for voice in this.voices {
            voiceList.Push(voice.display)
        }
        
        dropdown.Add(voiceList)
        dropdown.Choose(1)
        statusLabel.Text := "‚úÖ " . this.voices.Length . " voice(s) loaded"
        return true
    }
    
    GetSelectedVoice(dropdown) {
        selectedIndex := dropdown.Value
        if (selectedIndex = 0 || selectedIndex > this.voices.Length) {
            return {display: "", file: "", valid: false}
        }
        
        voice := this.voices[selectedIndex]
        if (InStr(voice.display, "‚ùå")) {
            return {display: voice.display, file: "", valid: false}
        }
        
        return {display: voice.display, file: voice.file, valid: true}
    }
    
    OpenVoicesFolder() {
        if (DirExist(".\voices")) {
            Run("explorer.exe .\voices")
            return true
        }
        return false
    }
} 

